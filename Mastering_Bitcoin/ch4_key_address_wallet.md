# Mastering Bitcoin (by 안드레아스 M.안토노풀로스)

#### 블록체인 코어 개발 스터디 3주차 (4/20)
---
# 4장 : 키, 주소, 지갑

## 들어가기

사용자의 지갑에는 개인키와 공개키가 쌍으로 생성되어 저장된다. 공개키는 비트코인을 전송받을 때 사용되며, 개인키는 전송받은 비트코인을 소비하기 위해 거래에 서명을 할 때 사용된다. 개인키로부터 공개키와 기타 등등이 모두 파생되어 생성되기 때문에 절대 잃어버리면 안 되고 유출되면 안된다.   

### 공개키의 암호법과 암호화폐
### 개인키와 공개키
앞서 말했듯이 개인키에서 공개키와 비트코인 주소가 생성되는데, 타원곡선 곱셈함수를 이용해서 개인키(k)로부터 공개키(K)를 생성한다. 타원곡선 곱셈함수는 일방 암호함수이기 때문에 개인키로부터 공개키를 계산해낸 다음에 거꾸로 공개키로부터 개인키를 구할 수 없게 되어 있다. 

### 개인키
개인키는 무작위로 뽑은 숫자를 이용하여 생성된다. 간단히 말해 1~2^256 사이의 숫자를 임의로 선택하는 것이다. 조금 더 정확히 설명하면, 개인키는 1~n-1 사이의 숫자를 뽑는 것이고, 여기서 n은 상수로 2^256보다 조금 작은 값이다. 보통 개인키는 16진법 포맷으로 4비트씩 64개의 16진수로 표현된 숫자로 표현된다. 

### 공개키
공개키는 타원곡선 곱셈함수를 이용해서 개인키로부터 생성되고, Inverse 계산이 불가능하다. 공개키 K는 K= k(개인키) * G라는 식으로 계산이 되는데, G는 생성포인트라는 상수이다.

### 타원곡선 암호법

### 공개키 생성하기
K를 계산하면 (x, y) 좌표가 나오는데, 이 둘을 이어 붙이면 그게 공개키인데, 공개키라는 것을 알리기 위해 앞에 접두어 `04`를 붙인다. 개인키 k와 공개키 K의 관계는 고정되어 있지만, k값에서 K값 쪽으로 한 방향으로만 계산할 수 있다(보안을 생각하면 당연한거지!)

## 비트코인 주소
비트코인 주소는 숫자와 문자로 구성된 문자열로, 공개키로부터 생성된다. 마찬가지로 역방향 계산이 어렵기 때문에 나에게 돈을 전송하고자 하는 어떤 누구와도 공유할 수 있다. 공개키 K를 가지고 `SHA256` 해시를 계산한 후 다시 `RIPEMD160` 해시를 돌리면 160바이트의 숫자가 생성된다.  

`A = RIPEMD160(SHA256(K)) (A는 비트코인 주소, K는 공개키) `

비트코인 주소는 이 계산 결과를 바로 가져다 쓰는 게 아니라 `Base58Check`이라는 인코딩 방법으로 인코딩을 한 값이 쓰인다. Base58Check은 58개의 숫자/문자와 검사합을 이용해서 값을 생성하는 체계인데, 비슷한 모양의 문자를 쓰지 않음으로써 혼란을 방지하도록 한다.

### Base58과 Base58Check 인코딩
`Base64`는 소문자 26 / 대문자 26 / 숫자 10 / 특수문자 '+', '/' 등 64개 문자로 데이터를 표현하는 방식인데, Base58은 이 중에서 모양이 비슷한 대문자 O 숫자 0, 소문자 l, 숫자 1과 특수문자를 쓰지 않는 버전이라고 생각하면 된다. 거기에 데이터 오류를 검사하기 위해서 Base58Check 인코딩 기법을 사용하는데, Checksum(검사합)이란 데이터 끝부분에 데이터 정합성을 검사하기 위해서 덧붙이는 4바이트 데이터이다.   

앞서 계산된 A라는 주소 앞에 이게 주소라고 알려주는 접두어를 붙이고 이중-SHA 해쉬를 돌려 앞 4바이트를 검사합으로 사용하여 전체를 Base58로 인코딩하면 우리가 사용할 최종 비트코인 주소가 나온다.  

`최종 비트코인 주소 = Base58(0x00 + A + SHA256(SHA256(0x00 + A))[:4Byte])`  

### 키 포맷
개인키와 공개키는 다양한 포맷으로 표현될 수 있다. 모두 같은 데이터를 다른 방식으로 표현한 것이라고 이해하면 된다. 그럼 당연히 이 데이터가 어떤 방식으로 포매팅된 것인지를 나타내주어야 할텐데, 이는 접두부를 보고 구분한다.

#### 개인키 포맷
개인키의 경우 Hex 포맷은 접두부가 특별히 없고, WIF의 경우 접두부 5를, WIF-압축형의 경우 접두부 K 혹은 L을 사용한다.  

#### 공개키 포맷
공개키는 크게 압축 공개키와 비압축 공개키로 표현할 수 있다. 공개키는 앞서 설명한대로 (x, y) 좌표로 표현되는데 공개키는 접두부 04 뒤에 256비트 숫자 2개로 구성된다. 접두부 04는 비압축 공개키를 뜻하고, 02 또는 03은 압축 공개키를 뜻한다.

#### 압축 공개키
거래 크기를 줄이고 블록체인 DB 양을 줄이기 위해 압축 공개키 방식이 도입되었다. 주된 아이디어는 공개키의 (x, y) 좌표값은 곡선함수 위의 한 점이기 때문에 x값만 알아도 y값을 계산할 수 있으니 공개키에 x값만 사용해도 된다는 것이다. 그래서 압축 공개키의 경우에는 접두부를 04 대신 02나 03을 사용하는데 두 버전을 사용하는 이유는 곡선함수가 x축에 대칭인 함수이기 때문에 y값이 양수인지 음수인지를 구분하기 위함이다.  

`A = RIPEMD160(SHA256(K)) (A는 비트코인 주소, K는 공개키) `
`최종 비트코인 주소 = Base58(0x00 + A + SHA256(SHA256(0x00 + A))[:4Byte])`  

위의 두 식에서 K를 표현하는 방식이 달라졌기 때문에 같은 개인키에서 생성된 공개키임에도 불구하고 당연히 A와 최종 비트코인 주소값이 달라질 것이다.  

#### 압축 개인키
압축 개인키는 개인키를 압축했다는 이야기가 아니고, 압축 공개키를 생성하는 데에 사용된 개인키라는 것을 의미한다. 모든 비트코인 지갑이 압축 공개키를 지원하면 좋겠지만 (현재는 어떻게 되는지 모르겠으나) 지원하는 지갑도 있고 지원하지 않는 지갑도 있기 때문에 어떤 형태의 공개키와 주소를 찾아야 하는지 알려주는 역할을 한다.  

내가 이해하기론 어떤 개인키든지 압축 공개키 / 비압축 공개키 모두 생성할 수 있지만 검색의 효율성을 위해서 개인키에 표시를 해두고 이 개인키에서 생성된 공개키는 압축형으로 만들어졌다 혹은 비압축형 공개키를 사용한다는 정보를 주기 위해서 구분한 것 같다.  


## 지갑
**지갑은 비트코인이 아닌 키를 담고 있는 곳이다.**  

### 비결정적(무작위) 지갑
비결정적 지갑은 무작위로 생성된 개인키를 모아 놓는 장소이다. 개인키 간에 어떠한 연관성도 없기 때문에 관리나 백업 등이 복잡하고, 잃어버렸을 때 복구할 수 없기 때문에 자주 백업을 해놓아야 한다. 백업이 많이 필요하다는 것은 그만큼 보안에 취약할 수 있다는 것을 의미하기도 한다.  

### 결정적(종자) 지갑
결정적 키 생성법은 공통의 seed에서 개인키를 생성하는 방식이다. 그래서 seed만 알면 생성된 개인키 모두를 파악할 수 있어 특정 시기에 백업을 한번만 해놓아도 된다.  

### 연상기호 코드 워드
연상기호 코드는 결정적 지갑을 얻기 위해 종자로 이용하는 난수를 표현하는 영어 단어열이다. 이 단어열만 있으면 종자를 재현할 수 있고, 추출키를 전부 재현할 수 있게된다. 

### 계층 결정적 지갑
계층 결정적 지갑(HD 지갑)에는 트리 구조에서 생성된 키를 담고 있다. 부모키가 자식키들을 만들어낼 수 있고, 자식키가 손자키 들을 만들어낼 수 있다. HD지갑의 장점은 사용자들이 개인키에 접근하지 않고도 공개키 열을 생성할 수 있다는 것이다.

#### 종자로부터 HD 지갑 생성하기
근원 종자(Root Seed)를 HMAC-SHA512 알고리즘에 입력하면 해시 결과값을 이용해서 마스터 개인키(m)와 마스터 체인코드를 생성한다. 마스터 개인키를 통해서 마스터 공개키가 생성되겠지? 부모키에서 자식키를 생성하는 함수에 엔트로피를 도입하기 위해서 체인코드를 사용하는데 이것이 없으면 부모키가 있어도 자식키를 생성할 수 없다. 

#### 개인 자식 키 유도하기
자식키를 유도하기 위해서는 부모 개인키 혹은 공개키 + 체인코드(256비트) + 색인번호 이 3가지가 필요하다. 최초의 체인코드 종자는 무작위 데이터에서 얻어지지만 두번째부터는 그 부모의 체인코드에서 얻어진다.  

위에서 언급한 3가지를 합쳐서 해쉬를 돌리면 512비트 해쉬값이 만들어지는데 이를 반으로 쪼개서 앞부분은 자식 개인키를 생성하는 데에 쓰이고 뒷부분은 자식키 생성을 위한 체인코드로 쓰인다. 각 부모키는 20억 개의 자식키를 보유할 수 있다(사실상 무한대로 생성해낼 수 있다는 얘기).

#### 추출된 자식 키 이용하기
자식 개인키는 무작위로 생성된 건지, HD지갑에서 생성된 건지 구분을 할 수 없다. 자식키 유도함수 역시 일방 함수이기 때문에 이걸로 부모의 키를 유추할 수 없다(형제자매키도 못 찾는다). 그래서 이 방식으로 생성된 자식 개인키도 여타 개인키와 마찬가지로 자식 공개키를 생성하고 주소를 생성하고 나서 다른 키들과 동일한 방식으로 동작한다. 

#### 공개 자식키 유도하기 
부모 키와 체인코드를 합쳐놓은 것을 확장키라고 하는데, 부모 개인키 + 체인코드는 확장 개인키로, 지갑 내의 모든 브랜치를 복구하는 데에 쓰일 수 있고, 부모 공개키 + 체인코드는 확장 공개키로, 자식 공개키를 생성하는 데에 사용할 수 있다.  

HD지갑의 중요한 특성 중 하나가 개인키 없이도 공개부모키로부터 공개 자식키를 얻을 수 있다는 것이다. 확장 공개키를 사용하면 개인키들을 외부에 노출하지 않으면서도 자식 공개키와 주소를 생성할 수 있어 안전한 어플리케이션을 만들 수 있다. 하지만 이 방법으로는 비트코인 소비가 불가능하겠지 (개인키를 모르니까)

## 고급키와 주소
### 암호화된 개인키
개인키의 보안은 굉장히 중요하다. 그래서 보안을 강화하기 위해 개인키를 Passphrase로 암호화한 다음 Base58Check으로 인코딩 한 것이 암호화된 개인키이다. 접두부가 6P로 시작하는 키는 암호화된 것으로 이해하면 된다.  

### Pay-to-Script Hash와 다중서명 주소
Pay-to-Script Hash 주소는 3으로 시작하고 이 주소는 비트코인 거래의 수령인을 공개키 소유주가 아닌 스크립트 해시로 지정한다. 3으로 시작된 주소로 송금된 돈은 공개키와 개인키 서명 이외에도 해당 스크립트를 만족해야 소유권이 증명되는 것이다. 
